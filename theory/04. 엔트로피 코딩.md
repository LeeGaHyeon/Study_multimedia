## 04. 엔트로피 코딩
런 랭스 인코딩 (Run length encoding)
  - 런 랭스 부호화(Run-length encoding, RLE) 또는 런 길이 부호화는 매우 간단한 비손실 압축 방법
    - 데이터에서 같은 값이 연속해서 나타나는 것을 그 개수와 반복되는 값만으로 표현
    - 연속된 값이 많이 있는 데이터에 효과적
    - 이 방법은 3번 이상 반복되는 문자들에 대해 이용되기 때문에 영어 문장에서는 잘 수행되기 어려움.

    - Run : 블록을 나타내는 값의 표현
    - Length : 블록이 반복되는 횟수 

런 랭스 코딩 예제 
  - W12BW12B3W24BW14 
  - W12개, 한개의B, W12개, B3개, W24개, 한개의B, W14개
  - 압축전에는 67글자 -> 압축 후 16글자
    - 67바이트 -> 16바이트 
    - 압축률 약 4..18

허프만 부호화 (1)
  - 1952년 당시 MIT 학생이었던 허프만에 의해 개발
  - 각 기호에 길이가 서로 다른 코드를 부여하는 방식인 가변길이 부호화(variable-length coding)방식
  - 허프만 코드는 정수의 길이로 나타나므로 최적의 코드 길이보다는 길게 표현됨 
  - 기호(문자)들이 자료집합에서 얼마나 자주 발생하는지를 안다면 발생되는 기호들의 비율에 따라 자주 반복되는 기호들을 더 적은 비트로 부호화 하는 것이 가능

허프만 알고리즘
  - 입력 기호를 리프 노드로 하는 이진트리를 만들어 접두부호(prefix)를 생성하는 알고리즘 
  - 1. 초기화 : 모든 기호를 출현 빈도수에 따라 나열한다.
  - 2. 단 한가지 기호가 남을 때 까지 아래 단계를 반복한다. 
    - 1. 목록으로부터 가장 빈도가 낮은 기호 노드 2개를 고른다.
    - 2. 기호 노드 2개를 자식으로 갖는 부모 노드를 생성한 후 두 자식 노드의 빈도수를 더한 값을 할당한다.
    - 3. 목록에서 부모 노드에 포함된 기호를 제거한다. 

기호와 엔트로피
  - 기호의 발생 확률 및 불확실성
  
허프만 부호화 (2)
- 앞의 표 2-6에 대한 허프만 트리 생성
  - 허프만 트리는 이진트리의 일종
  - 허프만 트리의 생성은 단말 노드에서 시작하여 부모 노드를 생성하는 과정으로 진행
    1. 가장 확률이 낮은 두 개의 기호를 선택 => 기호 C와 A를 선택
    2. C와 A를 자식으로 하는 부모노드 AC를 생성한 후 두 자식 노드의 합을 할당 => 노드 AC의 확률은 21/80
    3. 재 단계에서 확률에 대한 오름차순으로 노드들을 나열하면 D,B,AC,E 순서임.
    4. 다시 최소 확률을 갖는 노드를 선택하면 D,B이고 이들을 자식으로 하는 부모 노드 BD를 생성
    5. 이 과정을 통해 루트 노드가 생성될 때까지 반복 

허프만 부호화 (3)

허프만 부호화 (4)
- 허프만 코드 부여
   - 각 기호는 허프만 트리의 단말 노드에 해당
   - 루트 노드에서 시작하여 해당 기호까지의 경로를 추적 
    - 왼쪽 노드는 0, 오른쪽 노드는 1으로 부여
    - 0과 1을 변경하는 것은 무방하며 일관성 있게 부여 
   - 기호A는 루트노드에서 왼쪽에 위치하므로 0, ACE 노드의 다시 왼쪽에 위치하므로 0, AC 노드의 오른쪽에 위치하므로 1이므로 기호 A에 대한 허프만 코드는 001

허프만 부호화 (5)
- 압축률 계산
  - 각 기호를 문자로 취급하면 앞에서 계산한 것과 같이 80개의 기호를 위해 총 640비트가 필요
  - 허프만 부호화를 사용한 경우 기호A는 3비트로 표현하는데 80번중에서 13번 나타나므로 기호A를 표현하기 위해 필요한 총 비트수는 39비트 필요
  - 기호B는 38비트, 기호C는 27비트, 기호D는 34비트, 기호E는 44비트
  - 80개의 기호를 모두 저장하는데 182비트 필요
  - R = 640/182=3.5이므로 3.5:1의 압축률을 나타냄

허프만 부호화 (6)
- 부호화 결과를 저장할 때는 복원이 가능하도록 허프만 트리에 대한 정보를 함께 저장
- 복호화 과정
  - 압축 파일에서 한 비트씩 읽어 허프만 트리의 루트 노드에서 시작하여 하위 노드로 이동
  - 읽은 비트가 0이면 왼쪽, 1이면 오른쪽으로 이동
  - 단말 노드까지 이동한 경우 하나의 기호에 대한 복원이 끝난 경우이므로 그 다음 비트는 다시 루트노드에서 시작

허프만 부호화 추가 예제 (1)
- 엔트로피 코딩을 사용하지 않는다면, 3비트의 정보를 각 심볼에 할당
  - Efficiency = Entropy/ Average Symbol Length

허프만 부호화 추가 예제 (2)
- 허프만 트리

허프만 부호화 추가 예제 (3)
- 허프만 부호화를 통해 얻은 심볼 코드 

허프만 부호화 추가 예제 (4)
- 허프만 부호화를 이용한 텍스트 압축 (encoding)
  - 입력 : ABCAAH
  - 출력 : 0110000010111111
- 허프만 부호화를 이용한 텍스트 압축 복원 (decoding)
  - 입력 : 0110000010111111
  - 출력 : ABCAAH

## 산술부호화
산술부호화
- 허프만 코드의 문제점
  - 허프만 코드는 각 기호의 확률이 (1/2)의 지수승인 경우에만 정보 엔트로피 성능을 달성할 수 있음.
    - 하지만 확률이 (1/2)의 지수승인 경우는 매우 드뭄
  - 각 기호들은 독립적으로 부호화 된다.

- 산술부호화
  - 원본 데이터의 엔트로피에 가까운 압축 성능을 보일 수 있다.
  - 연속된 여러 개의 기호를 하나의 코드워드로 부호화 

산술부호화(1)
  - 산술부호화는 입력데이터를 0과 1사이의 하나의 실수로 변환하여 표현하는 방법
  - 허프만 부호화와 같이 입력 데이터들의 확률분포를 사용하여 부호화를 사용
  - 순서적인 입력데이터의 열을 실수로 표현된 하나의 부호화 코드로 표현

산술 부호화 알고리즘
  - step1) [0,1] 사이의 구간을 작은 조각(segment)으로 분할한다.
    - 분할 조각의 개수는 기호의 개수와 같다.
    - 각 분할 조각의 길이는 각 기호의 확률 값이 된다. 
  - 2) 입력 메세지의 첫번째 기호에 대응하는 segment를 선택한다.
  - 3) 선택한 segment를 step1 방식으로 재분할 한다.
  - 4) 다음 기호에 해당하는 segment를 step3 segment에서 선택한다. 
  - 5) 모든 메세지가 부호활 될때까지 step3,4 를 반복한다.
  - 6) 마지막 구간에서 선택한 segment의 값을 이진구간으로 나타내어 저장한다. 

산술부호화(2)
 
산술부호화(3)

산술부호화(4)
  - 첫 번째 기호가 A로 주어진 상황에서 나머지 기호들이 존재하는 구간은 2단계와 같음
  - 두번째 입력 기호 A는 -에서 169/6400 사이의 범위에 전재
  - A, A가 주어진 상황에서 기호 B가 존재하는 구간은 2197/512000DPTJ 5408~512000
  - A, A, B의 연속된 기호의 열은 이 범위 사이의 하나의 실수를 선택하여 표현
    - 예를 들어, 중간값을 선택하면 0.00742675

산술부호화(5)
  - 복호화 과정
    - 조금 전에 선택한 중간 값인 0.00742675를 사용하면 이 값은 0~13/80 사이의 값이므로 1단계에서는 기호 A를 복원
    - 2단계에서 이 값은 0~169/6400사이에 존재하므로 역시 기호A를 복원
    - 3단계에서는 기호B를 복원하여 원래 데이터인 A,A,B를 복원 

산술부호화 예제(1)
  - WIKI와 KIWI를 산술 부호화를 통해 인코딩하는 과정 

오늘 배운 내용
  - 런 랭스 부호화
  - 허프만 부호화
  - 산술 부호화 

자습 연습문제 3문제 풀기 

